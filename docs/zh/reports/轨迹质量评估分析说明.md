# 轨迹质量评估分析说明

## 概述

已成功生成**所有决策效率低下的树**（过拟合、欠拟合、分类不合格），并提取了它们的轨迹。现在可以使用这些轨迹来分析**哪种轨迹可能生成最好的树**。

## 生成的决策树统计

### 按树类型分组

| 树类型 | 数量 | 平均成功率 | 最低成功率 | 最高成功率 | 轨迹数 |
|--------|------|-----------|-----------|-----------|--------|
| **good** (好的树) | 4 | 0.7062 | 0.7003 | 0.7119 | 4,000 |
| **overfit** (过拟合) | 6 | 0.6932 | 0.6913 | 0.6965 | 6,000 |
| **poor** (分类不合格) | 4 | 0.3365 | 0.2805 | 0.4061 | 4,000 |
| **underfit** (欠拟合) | 11 | 0.5209 | 0.2805 | 0.6985 | 11,000 |

### 不好的树统计

- **分类不合格的树**: 8个，轨迹数: 8,000
- **过拟合的树**: 6个，轨迹数: 6,000
- **欠拟合的树**: 11个，轨迹数: 11,000

**总共不好的树**: 25个，轨迹数: 25,000

## 轨迹数据格式

每条轨迹包含以下信息：

```json
{
    "tendency": [...],           // 轨迹倾向值
    "sequence": [...],           // 轨迹序列
    "selection": [...],          // 轨迹选择
    "retrieval_time": 0.001,     // 检索时间
    "trajectory_length": 16,     // 轨迹长度
    "decision_effect": 0.7127,   // 决策成功率（该树的测试准确率）
    "tree_name": "必要-粗分裂",   // 决策树名称
    "tree_idx": 5,               // 决策树索引
    "tree_category": "good",     // 树类型: good, overfit, underfit, poor
    "is_overfitting": false,     // 是否过拟合
    "is_underfitting": false,    // 是否欠拟合
    "is_poor_performer": false,  // 是否分类不合格
    "overfitting_gap": 0.01,     // 过拟合差距（训练-测试）
    "train_accuracy": 0.72       // 训练准确率
}
```

## 分析目标

**核心问题：哪种轨迹可能生成最好的树？**

### 分析维度

1. **轨迹特征 vs 决策成功率**
   - 分析轨迹长度、检索时间等特征与决策成功率的关系
   - 找出高质量轨迹的特征模式

2. **轨迹类型 vs 树质量**
   - 比较来自不同树类型的轨迹特征
   - 识别能生成好树的轨迹特征

3. **轨迹模式识别**
   - 使用机器学习方法识别高质量轨迹的模式
   - 预测哪些轨迹可能生成最好的树

## 分析方法

### 方法1：特征统计分析

```python
import numpy as np
from collections import defaultdict

# 按决策成功率分组
high_quality = [t for t in trajectories if t["decision_effect"] > 0.70]
low_quality = [t for t in trajectories if t["decision_effect"] < 0.50]

# 分析轨迹特征
def analyze_trajectory_features(trajectories):
    features = {
        "avg_length": np.mean([t["trajectory_length"] for t in trajectories]),
        "avg_retrieval_time": np.mean([t["retrieval_time"] for t in trajectories]),
        "avg_decision_effect": np.mean([t["decision_effect"] for t in trajectories]),
    }
    return features

print("高质量轨迹特征:", analyze_trajectory_features(high_quality))
print("低质量轨迹特征:", analyze_trajectory_features(low_quality))
```

### 方法2：监督学习预测

使用轨迹特征预测决策成功率：

```python
from trajectary import Trajectary
from sklearn.ensemble import RandomForestRegressor
from sklearn.model_selection import train_test_split

# 加载轨迹数据
trajectary = Trajectary("", root_Node_array=[], trajectory_dict=trajectories)
trajectary.preprocess()
trajectary.cal_mixed_tendency_sequence_selection(method='full')

# 准备特征和标签
X = trajectary.mixed_feature_values
y = np.array([t["decision_effect"] for t in trajectories])

# 训练模型
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)
model = RandomForestRegressor()
model.fit(X_train, y_train)

# 预测哪些轨迹可能生成最好的树
predictions = model.predict(X_test)
best_trajectories = X_test[predictions > 0.70]
```

### 方法3：聚类分析

识别轨迹的模式：

```python
from sklearn.cluster import KMeans

# 使用轨迹特征进行聚类
kmeans = KMeans(n_clusters=5)
clusters = kmeans.fit_predict(X)

# 分析每个聚类的平均决策成功率
for i in range(5):
    cluster_trajectories = [trajectories[j] for j in range(len(trajectories)) if clusters[j] == i]
    avg_success = np.mean([t["decision_effect"] for t in cluster_trajectories])
    print(f"聚类 {i}: 平均成功率 = {avg_success:.4f}")
```

### 方法4：对比分析

对比不同树类型的轨迹特征：

```python
# 按树类型分组
good_trees = [t for t in trajectories if t["tree_category"] == "good"]
overfit_trees = [t for t in trajectories if t["tree_category"] == "overfit"]
underfit_trees = [t for t in trajectories if t["tree_category"] == "underfit"]
poor_trees = [t for t in trajectories if t["tree_category"] == "poor"]

# 分析每种类型的轨迹特征
for category, trajs in [("good", good_trees), ("overfit", overfit_trees), 
                         ("underfit", underfit_trees), ("poor", poor_trees)]:
    print(f"\n{category} 树的轨迹特征:")
    print(f"  平均轨迹长度: {np.mean([t['trajectory_length'] for t in trajs]):.2f}")
    print(f"  平均检索时间: {np.mean([t['retrieval_time'] for t in trajs]):.4f}")
    print(f"  平均决策成功率: {np.mean([t['decision_effect'] for t in trajs]):.4f}")
```

## 预期发现

### 1. 高质量轨迹的特征

可能发现：
- **轨迹长度适中**（既不太短也不太長）
- **检索时间较短**（效率高）
- **tendency/sequence/selection 的特定模式**

### 2. 低质量轨迹的特征

可能发现：
- **轨迹长度过短或过长**
- **检索时间过长**
- **tendency/sequence/selection 的异常模式**

### 3. 轨迹模式识别

可能发现：
- 某些特定的 `tendency`、`sequence`、`selection` 组合与高成功率相关
- 轨迹的统计特征（均值、方差等）与树质量相关

## 使用示例

### 完整分析脚本

```python
import json
import numpy as np
from trajectary import Trajectary
from sklearn.ensemble import RandomForestRegressor
from sklearn.model_selection import train_test_split
from sklearn.metrics import r2_score

# 1. 加载轨迹数据
with open("sample_trajectories.json", "r", encoding="utf-8") as f:
    trajectories = json.load(f)

print(f"加载了 {len(trajectories)} 条轨迹")

# 2. 准备轨迹数据
trajectory_dict = {i: traj for i, traj in enumerate(trajectories)}
trajectary = Trajectary("", root_Node_array=[], trajectory_dict=trajectory_dict)
trajectary.preprocess()
trajectary.cal_mixed_tendency_sequence_selection(method='full')

# 3. 准备特征和标签
X = trajectary.mixed_feature_values
y = np.array([t["decision_effect"] for t in trajectories])

print(f"特征维度: {X.shape}")
print(f"标签范围: {y.min():.4f} - {y.max():.4f}")

# 4. 训练预测模型
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
model = RandomForestRegressor(n_estimators=100, random_state=42)
model.fit(X_train, y_train)

# 5. 评估模型
y_pred = model.predict(X_test)
r2 = r2_score(y_test, y_pred)
print(f"\n模型R²分数: {r2:.4f}")

# 6. 找出可能生成最好树的轨迹
predictions = model.predict(X)
best_indices = np.argsort(predictions)[-100:]  # 前100个
best_trajectories = [trajectories[i] for i in best_indices]

print(f"\n预测可能生成最好树的轨迹（前100个）:")
print(f"  平均预测成功率: {np.mean(predictions[best_indices]):.4f}")
print(f"  实际平均成功率: {np.mean([t['decision_effect'] for t in best_trajectories]):.4f}")

# 7. 分析高质量轨迹的特征
high_quality = [t for t in trajectories if t["decision_effect"] > 0.70]
print(f"\n高质量轨迹（成功率>0.70）的特征:")
print(f"  数量: {len(high_quality)}")
print(f"  平均轨迹长度: {np.mean([t['trajectory_length'] for t in high_quality]):.2f}")
print(f"  平均检索时间: {np.mean([t['retrieval_time'] for t in high_quality]):.4f}秒")
```

## 下一步工作

1. **运行分析脚本**：使用上述方法分析轨迹数据
2. **特征重要性分析**：找出哪些特征最重要
3. **轨迹筛选规则**：基于分析结果制定筛选规则
4. **验证**：使用筛选出的轨迹训练新树，验证效果

## 总结

✅ **已生成**: 25个决策树（包括所有不好的树）
✅ **已提取**: 25,000条轨迹
✅ **已标记**: 每条轨迹都有完整的树质量信息
✅ **可分析**: 可以使用多种方法分析哪种轨迹能生成最好的树

现在可以开始分析轨迹质量，找出能生成最好树的轨迹特征！

